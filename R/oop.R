# Classes and methods for dynpv
# =============================

#' Method to add two dynpv objects together
#'
#' Add together two objects each of class "dynpv"
#'
#' @inherit addprod params details return
#'
#' @export
"+.dynpv" <- function(e1, e2) addprod(e1, e2, mult=1)

#' Method to subtract one dynpv object from another
#'
#' Subtract one object of S7 class "dynpv" from another
#'
#' Present value of `e1-e2` is the present values from `e1` less that from `e2`.
#' Total uptake of `e1-e2` is the uptake from `e1` less that from `e2`. Take
#' care of this when using `$mean` of the summed object.
#'
#' @inherit addprod params return
#' @export
"-.dynpv" <- function(e1, e2) addprod(e1, e2, mult=-1)

#' Method to add two class_dynpv S7 objects together
#'
#' Add together two objects each of S3 class "dynpv": e1 + mult * e2
#'
#' @param e1 First "dynpv" object
#' @param e2 Second "dynpv" object
#' @param mult Numeric
#'
#' Present value is present value from `e1` plus `mult` times the present value
#' from `e2`. Total uptake is the uptake from `e1` plus `mult` times the uptake
#' from `e2`. Take care of this when using `$mean` of the summed object.
#'
#' @returns S3 object of class "dynpv"
#'
#' @export
addprod <- function(e1, e2, mult) {
  # Pull out xdata and subset of ydata; add dpvno=1 or 2 depending on source
  xdata <- e1$df |>
    dplyr::mutate(dpvno="x")
  ydata <- e2$df |>
    dplyr::mutate(dpvno="y")
  # Check that j, k and l vectors align
  if (length(xdata$j) != length(ydata$j)) {warning("Uptake vectors differ in length after trimming")}
  stopifnot(max(xdata$k) == max(ydata$k))
  stopifnot(max(xdata$l) == max(ydata$l))
  # Combine data
  jdata <- dplyr::bind_rows(xdata, ydata) |>
    # Spread
    tidyr::pivot_wider(
      id_cols = c(j, k, l, t),
      names_from = dpvno,
      values_from = c(uj, pv),
      values_fill = 0
    ) |>
    # Sum the present values from both objects
    dplyr::mutate(
      uj = uj_x + mult * uj_y,
      pv = pv_x + mult * pv_y
    ) |>
    dplyr::select(-uj_x, -uj_y, -pv_x, -pv_y) |>
    dplyr::as_tibble()
  # Create the resulting object
  class_dynpv(
    name = paste0(e1$name, " plus ", e2$name),
    df = jdata
  )
}

#' Constructor for Dynamic Present Value class
#'
#' A Dynamic Present Value object has a name and a proscribed dataset.
#'
#' @param name Name of object (character string)
#' @param df Dataframe of proscribed format, such as generated by
#'   [dynamicpv::dynpv()] and [dynamicpv::futurepv()].
#'
#' @return An object of class "dynpv", with additional properties:
#' - `ncoh` Number of cohorts of uptaking patients
#' - `uptake` Total number of uptaking patients
#' - `sum_by_coh` Tibble of summarized calculation results for each uptake cohort
#' - `total` Total present value
#' - `mean` Average present value per uptaking patient (=total/uptake)
#'
#' @export
class_dynpv <- function(name, df) {
  ncoh <- max(df$k)
  ntimes <- length(unique(df$l))
  tempout1 <- df |>
    dplyr::summarize(mean=mean(uj), sd=sd(uj), .by=c(j, l)) |>
    dplyr::rename(tzero = l) |>
    dplyr::summarize(uptake=sum(mean), .by=tzero)
  uptake <- if (nrow(tempout1)==1) tempout1$uptake else tempout1
  tempout2 <- df |>
    # Summing over k, where uj does not vary by k
    dplyr::summarize(spv = sum(pv), .by=c(j, l)) |>
    dplyr::rename(tzero = l)
  sum_by_coh <- if (nrow(tempout2)==1) tempout2$spv else tempout2
  tempout3 <- df |>
    dplyr::summarize(total = sum(pv), .by=c(l)) |>
    dplyr::rename(tzero = l)
  total <- if (nrow(tempout3)==1) tempout3$total else tempout3
  mean <- if (length(total)==1) {
    total / uptake
  } else {
    dplyr::left_join(total, uptake, dplyr::join_by(tzero)) |>
      dplyr::mutate(mean = total / uptake) |>
      dplyr::select(-total, -uptake)
  }

  cds <- structure(
    class = "dynpv",
    list(
      name = name,
      df = df,
      ncoh = ncoh,
      ntimes = ntimes,
      uptake = uptake,
      sum_by_coh = sum_by_coh,
      total = total,
      mean = mean
    )
  )

  check_dynpv(cds)

  return(cds)
}

check_dynpv <- function(self) {
  if (!is.data.frame(self$df)) {
    "$df must be a data.frame"
  } else if (nrow(self$df) == 0) {
    "$df cannot be an empty tibble"
  } else if (!("j" %in% colnames(self$df))) {
    "$df must contain a field named j"
  } else if (!("k" %in% colnames(self$df))) {
    "$df must contain a field named k"
  } else if (!("l" %in% colnames(self$df))) {
    "$df must contain a field named l"
  } else if (!("uj" %in% colnames(self$df))) {
    "$df must contain a field named uj"
  } else if (!("pv" %in% colnames(self$df))) {
    "$df must contain a field named pv"
  } else if (self$ntimes < 1) {
    "$df must contain at least one unique value of l (tzero)"
  }

  return(invisible(self))
}

#' @export
print.dynpv <- function(x, ...) {
  cat("This is a dynpv S3 object, named", x$name, ". \n")
  cat("     Number of cohorts:            ", x$ncoh, "\n")
  cat("     Number of times:              ", x$ntimes, "\n")
  # Output depends on whether $ntimes>1
  if (x$ntimes>1) {
    # Create a tibble
    tib <- x$uptake |>
      dplyr::left_join(x$total, dplyr::join_by(tzero)) |>
      dplyr::left_join(x$mean, dplyr::join_by(tzero))
    cat("\n Uptake, total and mean present values by timepoint: \n")
    print(tib)
  }
  else {
    cat("     Total uptake:                 ", x$uptake, "\n")
    cat("     Total present value:          ", x$total, "\n")
    cat("     Mean present value:           ", x$mean, "\n")
  }
  # Other values
  cat("\n The full dataset is available using $df. \n")

  invisible(x)
}
