# Classes and methods for dynpv
# =============================

# Apparently you should do this
# https://rconsortium.github.io/S7/articles/packages.html
.onLoad <- function(...) {
  S7::methods_register()
}

# There is no ability to formally document S7 methods yet
# https://rconsortium.github.io/S7/articles/packages.html#:~:text=Documentation%20and%20exports,/S7/issues/315
# and my documentation of the class_dynpv S7 class just results in a codoc error on calling check()

# @title S7 Class Representing a Dynamic Present Value object
# @description A Dynamic Present Value object has a name and a proscribed dataset.
# @param name Name of object (character string)
# @param df Dataframe of proscribed format, such as generated by `dynamicpv::dynpv()` and `dynamicpv::futurepv()`.
# @return An object of class `class_dynpv`, with additional properties:
# - `ncoh` Number of cohorts of uptaking patients
# - `uptake` Total number of uptaking patients
# - `sum_by_coh` Tibble of summarized calculation results for each uptake cohort
# - `total` Total present value
# - `mean` Average present value per uptaking patient (=total/uptake)
# @export
class_dynpv <- S7::new_class(
  name = "class_dynpv",
  properties = list(
    # Innate properties: name and data
    name = S7::class_character, # The 'name' property is a string
    df = S7::class_data.frame, # The 'data' property is a data.frame
    # Computed properties
    # Number of the cohort = length(uptakes) = max(uj)
    ncoh = S7::new_property(
      getter = function(self) max(self@df$k)
    ),
    # Size of the cohort = sum(uptakes) = sum of uj such that k==1
    uptake = S7::new_property(
      getter = function(self) {
        outuptake <- self@df |>
          dplyr::summarize(mean=mean(uj), sd=sd(uj), .by=c(j, l)) |>
          dplyr::rename(tzero = l) |>
          dplyr::summarize(uptake=sum(mean), .by=tzero)
        if (nrow(outuptake)==1) outuptake$uptake else outuptake
      }
    ),
    # Sum PVs by cohort and tzero
    sum_by_coh = S7::new_property(
      getter = function(self) {
        self@df |>
          # Summing over k, where uj does not vary by k
          dplyr::summarize(spv = sum(pv), .by=c(j, l)) |>
          dplyr::rename(tzero = l)
      }
    ),
    # Total present value, by tzero
    total = S7::new_property(
      getter = function(self) {
        outpv<- self@sum_by_coh |>
          dplyr::summarize(total = sum(spv), .by=c(tzero)) |>
          dplyr::select(tzero, total)
        if (nrow(outpv)==1) outpv$total else outpv
      }
    ),
    # Mean present value, by tzero - a bit duplicative of total
    mean = S7::new_property(
      getter = function(self) {
        if (length(self@total)==1) (self@total/self@uptake) else {
          dplyr::left_join(self@total, self@uptake, dplyr::join_by(tzero)) |>
            dplyr::mutate(mean=total/uptake) |>
            dplyr::select(-total, -uptake)
          }
     }
    )
  ),
  # Validation of properties
  validator = function(self) {
    if (!is.data.frame(self@df)) {
      "@df must be a data.frame"
    } else if (nrow(self@df) == 0) {
      "@df cannot be an empty tibble"
    } else if (!("j" %in% colnames(self@df))) {
      "@df must contain a field named j"
    } else if (!("k" %in% colnames(self@df))) {
      "@df must contain a field named k"
    } else if (!("l" %in% colnames(self@df))) {
      "@df must contain a field named l"
    } else if (!("uj" %in% colnames(self@df))) {
      "@df must contain a field named uj"
    } else if (!("pv" %in% colnames(self@df))) {
      "@df must contain a field named pv"
    }
  }
)

# New generics for add and subtract
# Do not use - because + and - are builtins, so doing this will mess-up all other use of + and -
#`+` <- new_generic("+", c("e1", "e2"))
#`-` <- new_generic("-", c("e1", "e2"))

# @title Method to add two class_dynpv S7 objects together
# @description Add together two objects each of S7 class `class_dynpv`
# @param e1 First `class_dynpv` object
# @param e2 Second `class_dynpv` object
# Present value of `e1+e2` is sum of present values from `e1` and `e2`.
# Total uptake of `e1+e2` is sum of uptake from `e1` and `e2`. Take care of this when using `@mean` of the summed object.
# @returns S7 object of class `class_dynpv`
# @export
S7::method(`+`, signature = list(e1 = class_dynpv, e2 = class_dynpv)) <- function(e1, e2) {
  # Pull out xdata and subset of ydata; add dpvno=1 or 2 depending on source
  xdata <- e1@df |>
    dplyr::mutate(dpvno="x")
  ydata <- e2@df |>
    dplyr::mutate(dpvno="y")
  # Check that j, k and l vectors align
  if (length(xdata$j) != length(ydata$j)) {warning("Uptake vectors differ in length after trimming")}
  stopifnot(max(xdata$k) == max(ydata$k))
  stopifnot(max(xdata$l) == max(ydata$l))
  # Combine data
  jdata <- dplyr::bind_rows(xdata, ydata) |>
    # Spread
    tidyr::pivot_wider(
      id_cols = c(j, k, l, t),
      names_from = dpvno,
      values_from = c(uj, pv),
      values_fill = 0
    ) |>
    # Sum the present values from both objects
    dplyr::mutate(
      uj = uj_x + uj_y,
      pv = pv_x + pv_y
    ) |>
    dplyr::select(-uj_x, -uj_y, -pv_x, -pv_y) |>
    dplyr::as_tibble()
  # Create the resulting object
  class_dynpv(
    name = paste0(e1@name, " plus ", e2@name),
    df = jdata
  )
}

# Method to subtract one class_dynpv S7 object from another
# @description Subtract one object of S7 class `class_dynpv` from another
# @param e1 First `class_dynpv` object
# @param e2 Second `class_dynpv` object
# Present value of `e1-e2` is the present values from `e1` less that from `e2`.
# Total uptake of `e1-e2` is the uptake from `e1` less that from `e2`. Take care of this when using `@mean` of the summed object.
# @returns S7 object of class `class_dynpv`
S7::method(`-`, signature = list(e1 = class_dynpv, e2 = class_dynpv)) <- function(e1, e2) {
  # Pull out xdata and subset of ydata; add dpvno=1 or 2 depending on source
  xdata <- e1@df |>
    dplyr::mutate(dpvno="x")
  ydata <- e2@df |>
    dplyr::mutate(dpvno="y")
  # Check that j, k and l vectors align
  if (length(xdata$j) != length(ydata$j)) {warning("Uptake vectors differ in length after trimming")}
  stopifnot(max(xdata$k) == max(ydata$k))
  stopifnot(max(xdata$l) == max(ydata$l))
  # Combine data
  jdata <- dplyr::bind_rows(xdata, ydata) |>
    # Spread
    tidyr::pivot_wider(
      id_cols = c(j, k, l, t),
      names_from = dpvno,
      values_from = c(uj, pv),
      values_fill = 0
    ) |>
    # Sum the present values from both objects
    dplyr::mutate(
      uj = uj_x - uj_y,
      pv = pv_x - pv_y
    ) |>
    dplyr::select(-uj_x, -uj_y, -pv_x, -pv_y) |>
    dplyr::as_tibble()
  # Create the resulting object
  class_dynpv(
    name = paste0(e1@name, " minus ", e2@name),
    df = jdata
  )
}