# Classes and methods for dynpv
# =============================

# Apparently you should do this
# https://rconsortium.github.io/S7/articles/packages.html
#.onLoad <- function(...) {
#  S7::methods_register()
#}

# Define an S7 class where 'data' is a tibble

#' S7 Class Representing a Dynamic Present Value object
#' @description
#' A Dynamic Present Value object has a name and a proscribed dataset.
#' @param name Name of object (character string)
#' @param data Tibble dataset of proscribed format, such as generated by `dynamicpv::dynpv()` and `dynamicpv::futurepv()`.
#' @returns An object of class `DynPV`. From the above innate properties, other properties are derived:
#' - `ncoh`: Number of cohorts of uptaking patients
#' - `uptake`: Total number of uptaking patients
#' - `sum_by_coh`: Tibble of summarized calculation results for each uptake cohort
#' - `total`: Total present value
#' - `mean`: Average present value per uptaking patient (=total/uptake)
class_dynpv <- S7::new_class(
  name = "class_dynpv",
  properties = list(
    # Innate properties: name and data
    name = S7::class_character, # The 'name' property is a string
    data = S7::class_data.frame, # The 'data' property is a data.frame - validator then requires data to be a tibble
    # Computed properties
    # Number of the cohort = length(uptakes) = max(uj)
    ncoh = S7::new_property(
      getter = function(self) max(self@data$k)
    ),
    # Size of the cohort = sum(uptakes) = sum of uj such that k==1
    uptake = S7::new_property(
      getter = function(self) {
        outuptake <- self@data |>
          dplyr::summarize(mean=mean(uj), sd=sd(uj), .by=c(j, l)) |>
          dplyr::rename(tzero = l) |>
          dplyr::summarize(uptake=sum(mean), .by=tzero)
        if (nrow(outuptake)==1) outuptake$uptake else outuptake
      }
    ),
    # Sum PVs by cohort and tzero
    sum_by_coh = S7::new_property(
      getter = function(self) {
        self@data |>
          # Summing over k, where uj does not vary by k
          dplyr::summarize(spv = sum(pv), .by=c(j, l)) |>
          dplyr::rename(tzero = l)
      }
    ),
    # Total present value, by tzero
    total = S7::new_property(
      getter = function(self) {
        outpv<- self@sum_by_coh |>
          dplyr::summarize(total = sum(spv), .by=c(tzero)) |>
          dplyr::select(tzero, total)
        if (nrow(outpv)==1) outpv$total else outpv
      }
    ),
    # Mean present value, by tzero - a bit duplicative of total
    mean = S7::new_property(
      getter = function(self) {
        if (length(self@total)==1) (self@total/self@uptake) else {
          dplyr::left_join(self@total, self@uptake, dplyr::join_by(tzero)) |>
            dplyr::mutate(mean=total/uptake) |>
            dplyr::select(-total, -uptake)
          }
     }
    )
  ),
  # Validation of properties
  validator = function(self) {
    if (!tibble::is_tibble(self@data)) {
      "@data must be a tibble"
    } else if (nrow(self@data) == 0) {
      "@data cannot be an empty tibble"
    }
  }
)

# New generics for add and subtract
# Do not use - because + and - are builtins, so doing this will mess-up all other use of + and -
#`+` <- new_generic("+", c("e1", "e2"))
#`-` <- new_generic("-", c("e1", "e2"))

# Method to add two Dynamic PV objects together
S7::method(`+`, signature = list(e1 = class_dynpv, e2 = class_dynpv)) <- function(e1, e2) {
  # Pull out xdata and subset of ydata; add dpvno=1 or 2 depending on source
  xdata <- e1@data |>
    dplyr::mutate(dpvno="x")
  ydata <- e2@data |>
    dplyr::mutate(dpvno="y")
  # Check that j, k and l vectors align
  if (length(xdata$j) != length(ydata$j)) {warning("Uptake vectors differ in length after trimming")}
  stopifnot(max(xdata$k) == max(ydata$k))
  stopifnot(max(xdata$l) == max(ydata$l))
  # Combine data
  jdata <- bind_rows(xdata, ydata) |>
    # Spread
    tidyr::pivot_wider(names_from=dpvno, values_from=c(uj, pv), values_fill=0) |>
    # Sum the present values from both objects
    dplyr::mutate(
      uj = uj_x + uj_y,
      pv = pv_x + pv_y
    ) |>
    dplyr::select(-uj_x, -uj_y, -pv_x, -pv_y) |>
    tibble::as_tibble()
  # Create the resulting object
  class_dynpv(
    name = paste0(e1@name, " plus ", e2@name),
    data = jdata
  )
}

# Method to derive the difference between two Dynamic PV objects
S7::method(`-`, signature = list(e1 = class_dynpv, e2 = class_dynpv)) <- function(e1, e2) {
  # Pull out xdata and subset of ydata; add dpvno=1 or 2 depending on source
  xdata <- e1@data |>
    dplyr::mutate(dpvno="x")
  ydata <- e2@data |>
    dplyr::mutate(dpvno="y")
  # Check that j, k and l vectors align
  if (length(xdata$j) != length(ydata$j)) {warning("Uptake vectors differ in length after trimming")}
  stopifnot(max(xdata$k) == max(ydata$k))
  stopifnot(max(xdata$l) == max(ydata$l))
  # Combine data
  jdata <- bind_rows(xdata, ydata) |>
    # Spread
    tidyr::pivot_wider(names_from=dpvno, values_from=c(uj, pv), values_fill=0) |>
    # Sum the present values from both objects
    dplyr::mutate(
      uj = uj_x - uj_y,
      pv = pv_x - pv_y
    ) |>
    dplyr::select(-uj_x, -uj_y, -pv_x, -pv_y) |>
    tibble::as_tibble()
  # Create the resulting object
  class_dynpv(
    name = paste0(e1@name, " minus ", e2@name),
    data = jdata
  )
}