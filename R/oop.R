# Classes and methods for dynpv
# =============================

# Apparently you should do this
# https://rconsortium.github.io/S7/articles/packages.html
.onLoad <- function(...) {
  S7::methods_register()
}

# There is no ability to formally document S7 methods yet
# https://rconsortium.github.io/S7/articles/packages.html#:~:text=Documentation%20and%20exports,/S7/issues/315
# and my documentation of the class_dynpv S7 class just results in a codoc error on calling check()

# @title S7 Class Representing a Dynamic Present Value object
# @description A Dynamic Present Value object has a name and a proscribed dataset.
# @param name Name of object (character string)
# @param df Dataframe of proscribed format, such as generated by `dynamicpv::dynpv()` and `dynamicpv::futurepv()`.
# @return An object of class `class_dynpv`, with additional properties:
# - `ncoh` Number of cohorts of uptaking patients
# - `uptake` Total number of uptaking patients
# - `sum_by_coh` Tibble of summarized calculation results for each uptake cohort
# - `total` Total present value
# - `mean` Average present value per uptaking patient (=total/uptake)
# @export
class_dynpv <- S7::new_class(
  name = "class_dynpv",
  properties = list(
    # Innate properties: name and data
    name = S7::class_character, # The 'name' property is a string
    df = S7::class_data.frame, # The 'data' property is a data.frame
    # Computed properties
    # Number of the cohort = length(uptakes) = max(uj)
    ncoh = S7::new_property(
      getter = function(self) max(self@df$k)
    ),
    # Number of time periods
    ntimes = S7::new_property(
      getter = function(self) length(unique(self@df$l))
    ),
    # Size of the cohort = sum(uptakes) = sum of uj such that k==1
    uptake = S7::new_property(
      getter = function(self) {
        tempout1 <- self@df |>
          dplyr::summarize(mean=mean(uj), sd=sd(uj), .by=c(j, l)) |>
          dplyr::rename(tzero = l) |>
          dplyr::summarize(uptake=sum(mean), .by=tzero)
        if (nrow(tempout1)==1) tempout1$uptake else tempout1
      }
    ),
    # Sum PVs by cohort and tzero
    sum_by_coh = S7::new_property(
      getter = function(self) {
        tempout2 <- self@df |>
          # Summing over k, where uj does not vary by k
          dplyr::summarize(spv = sum(pv), .by=c(j, l)) |>
          dplyr::rename(tzero = l)
        if (nrow(tempout2)==1) tempout2$spv else tempout2
      }
    ),
    # Total present value, by tzero
    total = S7::new_property(
      getter = function(self) {
        tempout3 <- self@df |>
          dplyr::summarize(total = sum(pv), .by=c(l)) |>
          dplyr::rename(tzero = l)
        if (nrow(tempout3)==1) tempout3$total else tempout3
      }
    ),
    # Mean present value, by tzero - a bit duplicative of total
    mean = S7::new_property(
      getter = function(self) {
        if (length(self@total)==1) (self@total/self@uptake) else {
          dplyr::left_join(self@total, self@uptake, dplyr::join_by(tzero)) |>
            dplyr::mutate(mean = total / uptake) |>
            dplyr::select(-total, -uptake)
          }
     }
    )
  ),
  # Validation of properties
  validator = function(self) {
    if (!is.data.frame(self@df)) {
      "@df must be a data.frame"
    } else if (nrow(self@df) == 0) {
      "@df cannot be an empty tibble"
    } else if (!("j" %in% colnames(self@df))) {
      "@df must contain a field named j"
    } else if (!("k" %in% colnames(self@df))) {
      "@df must contain a field named k"
    } else if (!("l" %in% colnames(self@df))) {
      "@df must contain a field named l"
    } else if (!("uj" %in% colnames(self@df))) {
      "@df must contain a field named uj"
    } else if (!("pv" %in% colnames(self@df))) {
      "@df must contain a field named pv"
    } else if (self@ntimes < 1) {
      "@df must contain at least one unique value of l (tzero)"
    }
  }
)

# New generics for add and subtract
# Do not use - because + and - are builtins, so doing this will mess-up all other use of + and -
# addprod(e1, e2, mult) = e1 + mult x e2
#`+` <- S7::new_generic("+", c("e1", "e2"))
#`-` <- S7::new_generic("-", c("e1", "e2"))
addprod <- S7::new_generic("addprod", c("e1", "e2"))

# @title Method to add two class_dynpv S7 objects together
# @description Add together two objects each of S7 class `class_dynpv`: e1 + mult * e2
# @param e1 First `class_dynpv` object
# @param e2 Second `class_dynpv` object
# @param mult Numeric
# Present value is present value from `e1` plus `mult` times the present value from `e2`.
# Total uptake is the uptake from `e1` plus `mult` times the uptake from `e2`. Take care of this when using `@mean` of the summed object.
# @returns S7 object of class `class_dynpv`
# @export
S7::method(addprod, signature = list(e1 = class_dynpv, e2 = class_dynpv)) <- function(e1, e2, mult) {
  # Pull out xdata and subset of ydata; add dpvno=1 or 2 depending on source
  xdata <- e1@df |>
    dplyr::mutate(dpvno="x")
  ydata <- e2@df |>
    dplyr::mutate(dpvno="y")
  # Check that j, k and l vectors align
  if (length(xdata$j) != length(ydata$j)) {warning("Uptake vectors differ in length after trimming")}
  stopifnot(max(xdata$k) == max(ydata$k))
  stopifnot(max(xdata$l) == max(ydata$l))
  # Combine data
  jdata <- dplyr::bind_rows(xdata, ydata) |>
    # Spread
    tidyr::pivot_wider(
      id_cols = c(j, k, l, t),
      names_from = dpvno,
      values_from = c(uj, pv),
      values_fill = 0
    ) |>
    # Sum the present values from both objects
    dplyr::mutate(
      uj = uj_x + mult * uj_y,
      pv = pv_x + mult * pv_y
    ) |>
    dplyr::select(-uj_x, -uj_y, -pv_x, -pv_y) |>
    dplyr::as_tibble()
  # Create the resulting object
  class_dynpv(
    name = paste0(e1@name, " plus ", e2@name),
    df = jdata
  )
}

# @title Method to add two class_dynpv S7 objects together
# @description Add together two objects each of S7 class `class_dynpv`
# @param e1 First `class_dynpv` object
# @param e2 Second `class_dynpv` object
# Present value of `e1+e2` is sum of present values from `e1` and `e2`.
# Total uptake of `e1+e2` is sum of uptake from `e1` and `e2`. Take care of this when using `@mean` of the summed object.
# @returns S7 object of class `class_dynpv`
# @export
S7::method(`+`, signature = list(e1 = class_dynpv, e2 = class_dynpv)) <- function(e1, e2) {
  addprod(e1, e2, mult=1)
}

# Method to subtract one class_dynpv S7 object from another
# @description Subtract one object of S7 class `class_dynpv` from another
# @param e1 First `class_dynpv` object
# @param e2 Second `class_dynpv` object
# Present value of `e1-e2` is the present values from `e1` less that from `e2`.
# Total uptake of `e1-e2` is the uptake from `e1` less that from `e2`. Take care of this when using `@mean` of the summed object.
# @returns S7 object of class `class_dynpv`
S7::method(`-`, signature = list(e1 = class_dynpv, e2 = class_dynpv)) <- function(e1, e2) {
  addprod(e1, e2, mult=-1)
}

# Define a print method for the class_dynpv class
S7::method(print, class_dynpv) <- function(x, ...) {
  cat("This is a dynamicpv::class_dynpv S7 object, named", x@name, ". \n")
  cat("     Number of cohorts:            ", x@ncoh, "\n")
  cat("     Number of times:              ", x@ntimes, "\n")
  # Output depends on whether @ntimes>1
  if (x@ntimes>1) {
    # Create a tibble
    tib <- x@uptake |>
      dplyr::left_join(x@total, dplyr::join_by(tzero)) |>
      dplyr::left_join(x@mean, dplyr::join_by(tzero))
    cat("\n Uptake, total and mean present values by timepoint: \n")
    print(tib)
  }
  else {
    cat("     Total uptake:                 ", x@uptake, "\n")
    cat("     Total present value:          ", x@total, "\n")
    cat("     Mean present value:           ", x@mean, "\n")
  }
  # Other values
  cat("\n The full dataset is available using @df. \n")
  # Conventional to add this line
  invisible(x)
}